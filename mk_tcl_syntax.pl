#!/usr/local/bin/perl
#
#!/usr/bin/perl
#
# mk_tcl_syntax - create a supplementary syntax file based on the
# user's proc's.  If the procs file(s) use the Synopsys
# define_proc_attributes method, options will be picked up as well.
# For tips on using the define_proc_attributes method, see
# "My Favorite DC/PT Shell Tricks" on www.zimmerdesignservices.com
#
# This script assumes that one of the standard pt/dc syntax files has already
# been loaded.

$| = 1;  # force immediate output

$hilink = "hi! link";

# default format
$me = "me=e";
$he = "he=e-1";
$start = "\"\\\"\\\\<\${cmd}\\\\>\\\"\"" ;
$end = "\"[;}\\]\]\\|[^\\\\]\$\"" ;
$contains="\"\\\@\${prefix}containscluster\"";
$group = "tcltkCommand";
$link = "Special";

# Parse the command line
#
&process_options;

print STDERR "initial procs is @procs\n" if ($debug);
foreach $procdir (@procdirs) {
  if (-d $procdir) {
    push(@procs,<$procdir/*>);
  } else {
    print STDERR "procdir $procdir was specified, but isn't a directory!\n";
    exit;
  }
}
print STDERR "procs is now @procs\n" if ($debug);

# Header stuff
print "
\"This script assumes that one of the standard pt/dc syntax files has already been loaded.
\n";

# Now do the automatic generation
# First show (in comments) the files used
print "
\" The rest is generated by a perl script running over:
";
foreach $proc (@procs) { 
  print "\"    procedures file $proc\n";
}

print "\n\n";

# Processing of user procs files
foreach $proc (@procs) {
  $cmd = "";
  $items = "";
  open(PROC,"< $proc") || die "Error: Cannot open file $proc\n";
  while (<PROC>) {

    print STDERR "Main loop looking at line $_\n" if ($verbose);
    
    # When a proc command is found, save previous command (if it
    # exists), then set up for next.
    if (/^\s*proc\s+(\S+)/) {
      # save previous
      if ($cmd) {
        print STDERR "Found new cmd, saving cmd $cmd\n" if ($verbose);
        &save_command($cmd,$items,$start,$end,$contains,$group,$link,""); 
      }

      # init for next
      $cmd = $1;
      $items = "";
    }

    # Look for define_proc_attributes command and parse it
    if (/^\s*&?define_proc_attributes\s+(\S+)/) {
      # found - grab command and init brace counting vars
      $cmd = $1;
      $opens = 0;
      $closes = 0;
      print STDERR "Found define_proc_attributes for $cmd\n" if ($verbose);

      # pull until unescaped end of line and pairs of quotes
      while(/\\$/ || ((@quotes = /"/g)%2)) {
        $_ .= <PROC>;
      }
      print STDERR "define_proc_atts line is: $_\n" if ($verbose);

      if (/-define_args/) {
        # Now get rid of define_args and everything ahead of it
        s/.*-define_args//;
  
        # Keep pulling until we have at least one opening brace 
        # and equal numbers of opening and closing braces
        while(!(eof PROC) && ($opens eq 0) || ($opens ne $closes)) {
          $_ .= <PROC>;
          $opens = scalar(@temp = m/\{/g);
          $closes = scalar(@temp = m/\}/g);
        }
        # Clean out escapes and newlines
        s:\\?\n::g;
        # We now have the complete -define_args argument (I hope...)
  
        # Extract "-" options (must be preceeded by {\s* or they could be
        # part of a comment)
        $items = " " . join(" ",m/\{\s*(-\S+)/g);
      }

      # Go ahead and do the save.  This will cause duplicates (they were found
      # by proc code already), but duplicate cleanup code will handle that.
      &save_command($cmd,$items,$start,$end,$contains,$group,$link,""); 
    }

    # If an alias command appears, use the alias capability.
    # Doesn't handle multi-line...
    if (/[^;]\s*alias\s+(\S+)\s+(\S+)\s*$/) {
      # save previous
      if ($cmd) {
        &save_command($cmd,$items,$start,$end,$contains,$group,$link,""); 
      }

      $items = "";
      ($cmd = $1) =~ s/[\}\{"]//g;
      ($alias = $2) =~ s/[\}\{"]//g;
      # save the alias
      if ($cmd && $alias) {
        #print STDERR "Found alias $cmd for $alias on line $_\n";
        &save_command($cmd,$items,$start,$end,$contains,$group,$link,$alias); 
      }

      # init for next
      $cmd = $1;
    }
  }
  &save_command($cmd,$items,$start,$end,$contains,$group,$link,"");  # do last
}

if ($cmd_abv) {
  # Find and set the abbreviations for the commands
  foreach $cmd (sort keys %commands) {
    $cmd_list .= "$cmd ";
  }
  $cmd_abvs = &get_abbreviations($cmd_list);
  #print STDERR "cmd_abvs is $cmd_abvs\n";
  foreach $abv (split(/ /,$cmd_abvs)) {
    #print STDERR "abv is $abv\n";
    ($cmd = $abv) =~ s/[\[\]]//g;
    #print STDERR "cmd is $cmd\n";
    #print STDERR "abv is $abv\n";
    $abvstart = "\"\\<\\(";
    chop($abv); # get rid of ]
    while ($abv =~ /\[/) {
      $abvstart .=  "\\|$abv";
      chop($abv); # cut off last char
    }
    $abvstart =~ s/\[//g; # remove all the ['s
    $abvstart =~ s:\\\|::; # remove first \|
    $abvstart = $abvstart . "\\)";
    #print STDERR "abvstart is $abvstart\n";
    $abvstart .= "\\>\"";
    $commands{$cmd}{"abvstart"} = $abvstart;
  }
}

# Print out all the commands
foreach $cmd (sort keys %commands) {
  #print STDERR "command is $cmd\n";
  &print_command($cmd);
}

# Put all eval versions stuff at the end
if (@evals) {
  print "

\" Special handling for eval commands (allow following commands to syntax)
if ${prefix}_syntax_enable_eval
";
  foreach $eval_line (@eval_lines) {
    print "  $eval_line";
  }
  print "
endif

";
}

# Put all command abv stuff at the end, enabled by a switch
if ($cmd_abv) {
  print "
\" Default command abbreviations ON
if exists(\"${prefix}_syntax_use_cmd_abv\")
else
  let ${prefix}_syntax_use_cmd_abv = \"1\"
endif

\" Command abbreviations
if ${prefix}_syntax_use_cmd_abv
";
  foreach $cmd_abv_line (@cmd_abv_lines) {
    print "  $cmd_abv_line";
  }

  if (@evals) {
    print "

  \" Special handling for eval commands (allow following commands to syntax)
  if ${prefix}_syntax_enable_eval
";
  foreach $cmd_abv_eval_line (@cmd_abv_eval_lines) {
    print "    $cmd_abv_eval_line";
  }
  print "
  endif

";
  }
  print "
endif
";
}

#########################################################################
#
# Subroutines
#
#########################################################################

# save_command 
# Parse the new command into the data structure, fixing dups as necessary
sub save_command {
  my ($cmd,$items,$start,$end,$contains,$group,$link,$alias) = @_;
  print STDERR "in save, cmd is $cmd with items \"$items\"\n" if ($debug);
  print STDERR "Creating entry for command $cmd with items $items\n" if ($debug);
  if (exists $commands{$cmd}{"items"}) {
    print STDERR "\nWarning: duplicate entry for command $cmd\n" if ($verbose);
    $items = &resolve_dups($items,$commands{$cmd}{"items"});
  }
  $commands{$cmd}{"items"} = $items;
  $commands{$cmd}{"start"} = $start;
  $commands{$cmd}{"end"} = $end;
  $commands{$cmd}{"contains"} = $contains;
  $commands{$cmd}{"group"} = $group;
  $commands{$cmd}{"link"} = $link;
  $commands{$cmd}{"alias"} = $alias;
}

# resolve_dups 
# Resolve duplicate commands.
# This means returning an item list that is a superset of the duplicates
sub resolve_dups {
  my ($newitems,$olditems) = @_;
  my $items;
  my %temp_array;

  foreach $item (split(/\s+/,"$newitems $olditems")) {
    $temp_array{$item} = 1;
  }

  foreach $item (keys %temp_array) {
    $items .= " $item";
  }

  print STDERR "  Resolving duplicates...\n" if ($verbose);
  print STDERR "  newitems is $newitems\n" if ($verbose);
  print STDERR "  olditems is $olditems\n" if ($verbose);
  print STDERR "  resolved items is $items\n" if ($verbose);

  return $items;

}

# print_command 
# Do the actual output.
sub print_command {
  my ($cmd) = @_;
  my ($alias,$start,$end,$contains,$link);

  if ($commands{$cmd}{"alias"}) {
    $alias = $commands{$cmd}{"alias"};
    print STDERR "Found command $cmd aliased to $alias\n";
    $items = $commands{$alias}{"items"};
  } else {
    $items = $commands{$cmd}{"items"};
  }
  $start = $commands{$cmd}{"start"};
  $end = $commands{$cmd}{"end"};
  $contains = $commands{$cmd}{"contains"};
  $group = $commands{$cmd}{"group"};
  $link = $commands{$cmd}{"link"};
  eval "\$start = $start ;" ;
  eval "\$contains = $contains ;" ;
  foreach $reserved_word ("NONE", "ALL", "ALLBUT", "contains", "contained") {
     if ($items =~ s/\s+$reserved_word\s+/ /) {
       print STDERR "Warning: Command $cmd contained a reserved word - reserved word deleted from items list\n";
    }
  }

  # Sort items to make it easier to diff output files
  $items = &sort_items($items);
  print DICTFILE "$cmd $items\n" if ($dictfile);

  if (exists $evals{$cmd}) {
    $contains .= ",${group}ForEval";
    #print STDERR "\nCreating a special contains for eval command \"$cmd\" : \"$contains\"\n";
  }

  # Turn items list into version with abbreviations
  $items = &get_abbreviations($items);
  print STDERR "Printing entry for command $cmd with items $items\n" if ($verbose);

  # Only create keyword and link it if items exists (per Bram's request)
  if ($items) {
    # Remove special characters to get rid of W18 warnings
    ($cmd_clean = $cmd) =~ s/\&//g ; # & not allowed
    $cmd_clean  =~ s/:+/__/g; # :: not allowed
    
    print "syn keyword ${prefix}${cmd_clean} contained $items\n";

    print "${hilink} ${prefix}${cmd_clean} ${link}\n";
    $contains .= ",${prefix}${cmd_clean}" ;
  }

  (@starts) = &split_start($start);

  print "syn region ${group} matchgroup=tcltkCommandColor ";
  foreach $start (@starts) {
    print " $start";
  }
  print " matchgroup=NONE skip=\"^\\s*\$\" end=${end}${me},${he} contains=${contains}\n\n";

  # Push eval version into array for later printout
  unless (exists $evals{$cmd}) { # Don't put the evals themselves in
    $eval_line = "syn region ${group}ForEval matchgroup=tcltkCommandColor ";
    $eval_line = $eval_line . "start=$start";
    $eval_line = $eval_line .  " matchgroup=NONE skip=\"^\\s*\$\" end=${end}${me},${he} contains=${contains} contained\n\n";
    push(@eval_lines,$eval_line);
    #print "\"$eval_line\n";
  }

  # Push abv version into array for later printout
  if ($cmd_abv) {
    $abvstart = $commands{$cmd}{"abvstart"};
    if ($abvstart) {
      #eval "\$abvstart = $abvstart ;" ;
      #print STDERR "start is $start ; abvstart is $abvstart\n";
      (@starts) = &split_start($abvstart);
      $cmd_abv_line = "syn region ${group} matchgroup=tcltkCommandColor ";
      foreach $start (@starts) {
        $cmd_abv_line = $cmd_abv_line . " $start";
      }
      $cmd_abv_line = $cmd_abv_line . " matchgroup=NONE skip=\"^\\s*\$\" end=${end}${me},${he} contains=${contains}\n\n";
      push(@cmd_abv_lines,$cmd_abv_line);
    }
  }

  # Push abv + eval version into array for later printout
  if ($cmd_abv && (@evals)) {
    $abvstart = $commands{$cmd}{"abvstart"};
    if ($abvstart) {
      #eval "\$abvstart = $abvstart ;" ;
      #print STDERR "start is $start ; abvstart is $abvstart\n";
      #print "\" start is $start ; abvstart is $abvstart\n";
      $cmd_abv_eval_line = "syn region ${group}ForEval matchgroup=tcltkCommandColor ";
      $cmd_abv_eval_line = $cmd_abv_eval_line . "start=$abvstart";
      $cmd_abv_eval_line = $cmd_abv_eval_line . " matchgroup=NONE skip=\"^\\s*\$\" end=${end}${me},${he} contains=${contains}\n\n";
      push(@cmd_abv_eval_lines,$cmd_abv_eval_line);
    }
  }
}

# get_abbreviations
# Figure out minimum abbreviations for a list of items
sub get_abbreviations {
  my ($items) = @_;
  my (@list,@list1);
  my ($i,$j,$k);
  my ($item,$otheritem,$match,$othermatch,$newitem,$newitems,$uniqchar);
  
  if ($abv) {
    $items =~ s/^\s*//;
    @list = reverse sort split(/\s+/,$items);
  
    # Go through the list one by one
    for ($i=0 ; $i <= $#list ; $i++) {
      $item = $list[$i];
  
      # Create list without this entry
      @list1 = @list;
      splice (@list1,$i,1);
  
      # March through the char's of the current item until nothing matches
      $len = length($item);
      $uniqchar = 0;
      for ($j=0; $j <= $len-1; $j++) {
        $match = substr($item,0,$j+1);
        foreach $otheritem (@list1) {
          $othermatch = substr($otheritem,0,$j+1);
          if ($othermatch eq $match) {
            $uniqchar = $j+1;
          }
        }
      }
      # if the item starts with "-", and this is the unique match, move down
      # one character
      if (($item =~ /^-/) && $uniqchar == 0) {
        $uniqchar = 1;
      }
      
      $newitem = substr($item,0,$uniqchar+1);
      $newitem .= "[";
      $newitem .= substr($item,$uniqchar+1);
      $newitem .= "]";
      $newitems = "$newitem $newitems";
    }
  
    return $newitems;
  } else {
    print STDERR "Skipping abbreviations because \$abv is not set!\n";
  }
}

sub sort_items {
  my($items) = @_;
  my(@array);

  #print STDERR "pre-sort items is $items\n";
  @array = split(/\s+/,$items);
  @array = sort(@array);
  $items = join(" ",@array);
  #print STDERR "post-sort items is $items\n"
}

sub split_start {
  my ($start) = @_;
  my (@starts);

  # Modify start to version that requires ^ or [ before the command name.
  # This requires TWO start strings so that the [ one can have a one
  # char offset on the highlighting.  Prepend "start=" while we're at it
  # Treat { like [
  $origstart = $start;
  $start = "start=" . $start;
  ($starts[1] = $start) =~ s/^(start=\")/\1^$evalstring\\s*/;
  ($starts[2] = $start) =~ s/^(start=\")/\1\[\\[{\]\\s*/;
  $starts[2] =~ s/$/hs=s+1/;

  # Special case for else, elseif - allow } to start the sequence like [
  if ($cmd =~ /^else/) {
    ($starts[3] = $start) =~ s/^(start=\")/\1\\}\\s*/;
    $starts[3] =~ s/$/hs=s+1/;
  } else {
    $starts[3] = "";
  }

  # Special case for get_* commands - allow non-plural abbreviation
  if ($cmd =~ /^get_.*s/) {
    ($cmd_no_s = $cmd) =~ s/s$//;
    $starts[1] =~ s/$cmd/$cmd\\|$cmd_no_s/;
    $starts[2] =~ s/$cmd/$cmd\\|$cmd_no_s/;
  }
  return (@starts);
}

sub process_options {

  use Getopt::Long;
  
  # default variables
  $prefix = "pt"; # Should match with std file (pt or dctl)
  $abv = 1;  # default abv's on
  $cmd_abv = 1;  # default command abv's on

  die unless GetOptions(
    "help" => \$help,
    "verbose" => \$verbose,
    "debug" => \$debug,
    "proc=s" => \@procs,
    "procdir=s" => \@procdirs,
    "prefix=s" => \$prefix,
    "abv!" => \$abv,
    "dictionary=s" => \$dictfile,
    "cmd_abv!" => \$cmd_abv,
    "eval=s" => \@evals,
    );
  
  if ($help) {
    &show_help;
    exit;
  }

  if ($dictfile) {
    open(DICTFILE,"> $dictfile") || die "Could not open dictionary file $dictfile\n";
    print DICTFILE "\n\" Commands";
  }

  # Create a hash of evals
  foreach $eval (@evals) {
    $evals{$eval} = 1;
  }
}

sub show_help {
 print "Syntax:
    mk_tcl_syntax.pl [options]

  options:
  -debug	Turn on debug messages
  -verbose	Be chatty
  -proc file	Use procs file \"file\" (can be invoked multiple times).
  -prefix prefix Use \"prefix\" 
  -procdir dir	Use all files in  \"dir\" (can be invoked multiple times).
  -abv		Generate all valid abbreviations for command options.
                (Defaults ON, use -noabv to shut it off)
  -cmd_abv	generate all valid abbreviations for commands (doesn't work yet).
  -dict file	Create dictionary file \"file\" as dictionary output
  -eval string	\"string\" is the equivalent of \"eval\" (can be invoked multiple times).

  Common example:
    mk_tcl_syntax.pl -proc myprocs.dctl -proc groupprocs.dctl > mydctl.vim

  \n";
}

# when doing require or use we must return 1
1
